**Initial Handshake**
-IT sets up a listener that listens for a password passed to it on a specific port in the building.
	-Listener has a timeout time, for real-time IT to user interaction this could be as low as a couple minutes.
-The user enters the password into the client within the time frame and the server verifies the client is where it is supposed to be and used the correct password.
	-NOTE: After this initial connection is made, the port location is no longer checked.
-The client generates a string based on various system data that remains static most of the time, if not all the time, to identify itself and hashes it.
-The client then generates a long string of random data.
-A less-secure encryption method is used to pass the hashed system fingerprint and the random data to the server.
-The server receives the data and stores the hashed fingerprint for that specific user profile.
-The server then takes the random data and client fingerprint and combines them together.
-A function uses the previous key, in this case the user-entered password, to seed the RNG and 'randomly' build the first generated encryption key.


**Changing the key using junk data**
-The client uses the current time and other random data as the RNG seed and generates new junk data, which is sent to the server alone.
-The client also generates its hardware fingerprint, which is not sent to the server.
-The server receives the junk data from the client and combines it with the previously-stored client hardware fingerprint.
-Both the server and the client use the previously generated encryption key to seed the RNG and randomly create a new key from the combined junk data and client hardware fingerprint data.
	-Theoretically both of these keys should be exactly the same after being generated.
-The server then encrypts a packet with a success message inserted and sends the encrypted data using the new key to encrypt it to the client.
-The client then receives the encrypted data locked with the new key and tries to open it using the key that is locally generated by the client.
-If the success message is received, the client then sends a success message back, encrypted using the new key.
-If the server is able to read the message using the key, the server has then validated the client and switches to the new key permanently.
-Another success message is sent to the client encrypted using the new key, letting the client know that it has agreed to the newly agreed upon key.


**Changing ports**
-When the client appears on another port, the server will send a check packet to the old port.
-If the check packet gets a response, the server knows the legitimate client is online and an alert will trigger.
-The offline rolling authenticator ties to the hardware fingerprint, time and last key.
	-This should prevent someone from being able to copy the credentials from the client's computer and use them on another port/machine easily.
	-This also means if the client remains connected after the credentials are copied, the copied credentials will be invalidated once the new key is agreed upon.
-After the client is disconnected, the next time a junk packet should be generated and sent but is not, the server and client will mark the connection as offline.
-Once the system is marked offline, the offline rolling authenticator comes into play.
-The server also sets itself as listening for the connection, adding the server's old information as a potential reconnect on another port.
-Both the server and client mark the time they discovered they were disconnected from one another.
**Reconnected**
-After connecting to another port, the client sees it marked itself offline and on another port, so it creates new junk data.
-The client uses the current approximate time and previous key to generate a new key.
-The junk data is encrypted then passed to the server like normal, except the server sees the client is marked offline.
-The server goes through the same process the client just did of using the current approximate time and previous key to generate a new key.
-The server attempts to open the packet using the new key. If it can't it blacklists the connection profile entirely.
	-This means if the normal key generation method is used, it will be invalid since it should see itself offline as well.
-The server generates an encrypted success message using the newly verified key and sends it to the client.
-Upon receiving the encrypted message, the client immediately generates a normal new key (without the rolling authenticator) and sends junk data to the server to create the new key.
-If the server sent a verification message previously, it will accept the new junk data and derive the key from it and continue like normal.
-If the server did not send a verification message previously, the connection will be blacklisted.

**Attacking**
-In order to take control of this method, multiple security measures must be broken.
	-The legitimate client machine would have to be disconnected, since the server will send a check to the client's old port to check if it is online.
	
	Step 1: The attacker would have to get access to the sessionID(OTP Seed) from the target machine.
	Step 2: The attacker would have to be able to disconnect the target machine from the network.
	Step 3: The attacker would then have to spoof the ip address of the target using the captuared sessionID.
	
	-This would work however a new session id is generated every few min. So the attacker would have to get the sessionID and do
	all the the steps in a short window.

